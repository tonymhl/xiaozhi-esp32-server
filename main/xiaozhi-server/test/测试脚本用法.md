测试服务器资源使用情况。以下是可控制的资源压力测试脚本。

## 创建压力测试脚本

```bash
#!/bin/bash
# 文件名: resource_stress_test.sh
# 描述: 可控的CPU和内存压力测试脚本

STRESS_PID_FILE="/tmp/resource_stress.pid"
MEMORY_USAGE_PERCENT=80  # 内存使用百分比
CPU_USAGE_PERCENT=90     # CPU使用百分比
DURATION=300             # 默认运行时间（秒）

usage() {
    echo "用法: $0 {start|stop|status|restart}"
    echo "环境变量:"
    echo "  MEMORY_USAGE_PERCENT - 内存使用百分比 (默认: 80)"
    echo "  CPU_USAGE_PERCENT - CPU使用百分比 (默认: 90)"
    echo "  DURATION - 运行时间(秒) (默认: 300)"
    exit 1
}

calculate_memory_usage() {
    local total_mem=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    local mem_to_use=$((total_mem * MEMORY_USAGE_PERCENT / 100 / 1024))
    echo $mem_to_use
}

start_stress() {
    if [ -f "$STRESS_PID_FILE" ]; then
        echo "压力测试已经在运行中 (PID: $(cat $STRESS_PID_FILE))"
        return 1
    fi
  
    echo "开始资源压力测试..."
    echo "内存使用: ${MEMORY_USAGE_PERCENT}%"
    echo "CPU使用: ${CPU_USAGE_PERCENT}%"
    echo "持续时间: ${DURATION}秒"
  
    # 计算要使用的内存大小(MB)
    local mem_mb=$(calculate_memory_usage)
    echo "将使用大约 ${mem_mb}MB 内存"
  
    # 创建压力测试进程
    {
        # CPU压力测试 - 使用多个dd进程来消耗CPU
        for ((i=0; i<$(nproc); i++)); do
            while true; do
                dd if=/dev/zero of=/dev/null bs=1M count=1000 2>/dev/null
                sleep 0.$((100 - CPU_USAGE_PERCENT))
            done &
            echo $! >> "$STRESS_PID_FILE"
        done
      
        # 内存压力测试 - 使用dd分配内存
        dd if=/dev/zero of=/dev/shm/stress_memory bs=1M count=$mem_mb 2>/dev/null &
        echo $! >> "$STRESS_PID_FILE"
      
        # 设置超时停止
        sleep $DURATION
        stop_stress
        echo "压力测试已自动停止（超时: ${DURATION}秒）"
    } &
  
    echo $! >> "$STRESS_PID_FILE"
    echo "压力测试已启动，PID: $(cat $STRESS_PID_FILE | head -1)"
    echo "使用 '$0 stop' 来停止测试"
}

stop_stress() {
    if [ ! -f "$STRESS_PID_FILE" ]; then
        echo "没有运行的压力测试"
        return 1
    fi
  
    echo "停止压力测试..."
    while read pid; do
        if kill -0 $pid 2>/dev/null; then
            kill -TERM $pid 2>/dev/null
            sleep 1
            kill -KILL $pid 2>/dev/null 2>/dev/null
        fi
    done < "$STRESS_PID_FILE"
  
    # 清理内存文件
    rm -f /dev/shm/stress_memory
  
    # 删除PID文件
    rm -f "$STRESS_PID_FILE"
  
    echo "压力测试已停止"
}

status_stress() {
    if [ -f "$STRESS_PID_FILE" ]; then
        local main_pid=$(head -1 "$STRESS_PID_FILE")
        if kill -0 $main_pid 2>/dev/null; then
            echo "压力测试正在运行 (PID: $main_pid)"
          
            # 显示资源使用情况
            echo -e "\n当前系统资源使用情况:"
            echo "CPU使用率:"
            top -bn1 | grep "Cpu(s)" | head -1
            echo -e "\n内存使用情况:"
            free -h
            echo -e "\n负载情况:"
            uptime
        else
            echo "压力测试PID文件存在但进程未运行，清理中..."
            stop_stress
        fi
    else
        echo "压力测试未运行"
    fi
}

# 检查参数
if [ $# -lt 1 ]; then
    usage
fi

# 读取环境变量
[ ! -z "$MEMORY_USAGE_PERCENT" ] && MEMORY_USAGE_PERCENT=$MEMORY_USAGE_PERCENT
[ ! -z "$CPU_USAGE_PERCENT" ] && CPU_USAGE_PERCENT=$CPU_USAGE_PERCENT
[ ! -z "$DURATION" ] && DURATION=$DURATION

case "$1" in
    start)
        start_stress
        ;;
    stop)
        stop_stress
        ;;
    status)
        status_stress
        ;;
    restart)
        stop_stress
        sleep 2
        start_stress
        ;;
    *)
        usage
        ;;
esac
```

## 创建简化控制脚本

```bash
#!/bin/bash
# 文件名: stress_controller.sh
# 描述: 压力测试控制器 - 更简单的接口

STRESS_SCRIPT="./resource_stress_test.sh"

if [ ! -f "$STRESS_SCRIPT" ]; then
    echo "错误: 找不到压力测试脚本 $STRESS_SCRIPT"
    exit 1
fi

case "$1" in
    "start")
        # 可选的参数设置
        export MEMORY_USAGE_PERCENT=${2:-85}
        export CPU_USAGE_PERCENT=${3:-95}
        export DURATION=${4:-600}  # 10分钟默认
      
        echo "启动压力测试: 内存${MEMORY_USAGE_PERCENT}% CPU${CPU_USAGE_PERCENT}% 持续时间${DURATION}秒"
        bash "$STRESS_SCRIPT" start
        ;;
    "stop")
        bash "$STRESS_SCRIPT" stop
        ;;
    "status")
        bash "$STRESS_SCRIPT" status
        ;;
    "quick")
        # 快速测试 - 2分钟，70%资源
        echo "启动快速压力测试 (2分钟, 70%资源)"
        export MEMORY_USAGE_PERCENT=70
        export CPU_USAGE_PERCENT=70
        export DURATION=120
        bash "$STRESS_SCRIPT" start
        ;;
    *)
        echo "用法: $0 {start [mem% cpu% duration]|stop|status|quick}"
        echo "示例:"
        echo "  $0 start           # 使用默认参数"
        echo "  $0 start 80 90 300 # 内存80%, CPU90%, 5分钟"
        echo "  $0 quick           # 快速测试"
        echo "  $0 stop            # 停止测试"
        echo "  $0 status          # 查看状态"
        ;;
esac
```

## 使用方法

1. **保存脚本**：

```bash
# 保存主脚本
vi resource_stress_test.sh
chmod +x resource_stress_test.sh

# 保存控制脚本
vi stress_controller.sh  
chmod +x stress_controller.sh
```

2. **基本使用**：

```bash
# 启动测试（使用默认参数）
./stress_controller.sh start

# 启动自定义测试
./stress_controller.sh start 85 95 600

# 快速测试（2分钟，70%资源）
./stress_controller.sh quick

# 查看状态
./stress_controller.sh status

# 停止测试
./stress_controller.sh stop
```

3. **直接使用主脚本**：

```bash
# 设置环境变量（可选）
export MEMORY_USAGE_PERCENT=80
export CPU_USAGE_PERCENT=90
export DURATION=300

./resource_stress_test.sh start
./resource_stress_test.sh status
./resource_stress_test.sh stop
```

监控资源使用：

```bash
watch -n1 'free -h; echo; uptime; echo; ps aux --sort=-%cpu | head -10'
```
改进的版本使用了更高效的计算密集型任务（计算π值）和更好的内存分配策略，应该能够更有效地占用CPU和内存资源。

## 重要提醒

1. **谨慎使用**：此脚本会显著消耗系统资源，请在测试环境中使用或确保不会影响关键业务。
2. **监控资源**：测试期间使用以下命令监控：

```bash
# 监控CPU和内存
top

# 监控内存
free -h

# 监控系统负载
uptime

# 监控进程
ps aux | grep stress
```

3. **安全停止**：脚本包含自动超时停止功能，也可以通过stop命令随时手动停止。
4. **清理**：停止后会自动清理临时文件和进程。

这个方案提供了很好的可控性，您可以精确控制资源使用程度和持续时间，并且可以随时启停测试。
